/* tslint:disable */

// This file has been generated by https://github.com/horizon-games/protoc-gen-twirp_ts.
// Do not edit.
import * as google_protobuf from './google/protobuf/google.protobuf'
import * as subpkg from './subpkg/subpkg'


import {
  createTwirpRequest,
  Fetch,
  throwTwirpError
} from './twirp'


export interface ISearchRequest_Spec {
  pageNumber?: number
  resultPerPage?: number
  
  toJSON?(): object
}

export interface ISearchRequest_SpecJSON {
  page_number?: number
  result_per_page?: number
  toJSON?(): object
}

export class SearchRequest_Spec implements ISearchRequest_Spec {
  private readonly _json: ISearchRequest_SpecJSON;

  constructor(m?: ISearchRequest_Spec) {
    this._json = {};
    if (m) {
      this._json['page_number'] = m.pageNumber;
      this._json['result_per_page'] = m.resultPerPage;
    }
  }
  
  // pageNumber (page_number)
  public get pageNumber(): number {
    return this._json.page_number!
  }
  public set pageNumber(value: number) {
    this._json.page_number = value
  }
  
  // resultPerPage (result_per_page)
  public get resultPerPage(): number {
    return this._json.result_per_page!
  }
  public set resultPerPage(value: number) {
    this._json.result_per_page = value
  }
  
  static fromJSON(m: ISearchRequest_SpecJSON = {}): SearchRequest_Spec {
    return new SearchRequest_Spec({
      pageNumber: m['page_number']!,
      resultPerPage: m['result_per_page']!
    })
  }

  public toJSON(): object {
    return this._json
  }
}

export interface ISearchRequest {
  query?: string
  spec?: SearchRequest_Spec
  corpus?: SearchRequest_Corpus
  
  toJSON?(): object
}

export enum SearchRequest_Corpus {
  UNIVERSAL = 'UNIVERSAL',
  WEB = 'WEB',
  IMAGES = 'IMAGES',
  LOCAL = 'LOCAL',
  NEWS = 'NEWS',
  PRODUCTS = 'PRODUCTS',
  VIDEO = 'VIDEO'
}

export interface ISearchRequestJSON {
  query?: string
  spec?: SearchRequest_Spec
  corpus?: SearchRequest_Corpus
  toJSON?(): object
}

export class SearchRequest implements ISearchRequest {
  private readonly _json: ISearchRequestJSON;

  constructor(m?: ISearchRequest) {
    this._json = {};
    if (m) {
      this._json['query'] = m.query;
      this._json['spec'] = m.spec;
      this._json['corpus'] = m.corpus;
    }
  }
  
  // query (query)
  public get query(): string {
    return this._json.query!
  }
  public set query(value: string) {
    this._json.query = value
  }
  
  // spec (spec)
  public get spec(): SearchRequest_Spec {
    return this._json.spec!
  }
  public set spec(value: SearchRequest_Spec) {
    this._json.spec = value
  }
  
  // corpus (corpus)
  public get corpus(): SearchRequest_Corpus {
    return (<any>SearchRequest_Corpus)[this._json.corpus!]
  }
  public set corpus(value: SearchRequest_Corpus) {
    this._json.corpus = value
  }
  
  static fromJSON(m: ISearchRequestJSON = {}): SearchRequest {
    return new SearchRequest({
      query: m['query']!,
      spec: SearchRequest_Spec.fromJSON(m['spec']!),
      corpus: (<any>SearchRequest_Corpus)[m['corpus']!]!
    })
  }

  public toJSON(): object {
    return this._json
  }
}

export interface ISearchResponse {
  result?: subpkg.Result[]
  now?: string
  
  toJSON?(): object
}

export interface ISearchResponseJSON {
  result?: subpkg.Result[]
  now?: string
  toJSON?(): object
}

export class SearchResponse implements ISearchResponse {
  private readonly _json: ISearchResponseJSON;

  constructor(m?: ISearchResponse) {
    this._json = {};
    if (m) {
      this._json['result'] = m.result;
      this._json['now'] = m.now;
    }
  }
  
  // result (result)
  public get result(): subpkg.Result[] {
    return this._json.result || []
  }
  public set result(value: subpkg.Result[]) {
    this._json.result = value
  }
  
  // now (now)
  public get now(): string {
    return this._json.now!
  }
  public set now(value: string) {
    this._json.now = value
  }
  
  static fromJSON(m: ISearchResponseJSON = {}): SearchResponse {
    return new SearchResponse({
      result: (m['result']! || []).map((v) => { return subpkg.Result.fromJSON(v) }),
      now: m['now']!
    })
  }

  public toJSON(): object {
    return this._json
  }
}

export interface IDebugResponse {
  attributes?: google_protobuf.Struct
  revisionHash?: string
  
  toJSON?(): object
}

export interface IDebugResponseJSON {
  attributes?: google_protobuf.Struct
  revision_hash?: string
  toJSON?(): object
}

export class DebugResponse implements IDebugResponse {
  private readonly _json: IDebugResponseJSON;

  constructor(m?: IDebugResponse) {
    this._json = {};
    if (m) {
      this._json['attributes'] = m.attributes;
      this._json['revision_hash'] = m.revisionHash;
    }
  }
  
  // attributes (attributes)
  public get attributes(): google_protobuf.Struct {
    return this._json.attributes!
  }
  public set attributes(value: google_protobuf.Struct) {
    this._json.attributes = value
  }
  
  // revisionHash (revision_hash)
  public get revisionHash(): string {
    return this._json.revision_hash!
  }
  public set revisionHash(value: string) {
    this._json.revision_hash = value
  }
  
  static fromJSON(m: IDebugResponseJSON = {}): DebugResponse {
    return new DebugResponse({
      attributes: google_protobuf.Struct.fromJSON(m['attributes']!),
      revisionHash: m['revision_hash']!
    })
  }

  public toJSON(): object {
    return this._json
  }
}



// Services
export interface ISearchService {
  search: (data: SearchRequest, headers?: object) => Promise<SearchResponse>
  debug: (data: google_protobuf.Empty, headers?: object) => Promise<DebugResponse>
}

export class SearchService implements ISearchService {
  private hostname: string
  private fetch: Fetch
  private path = '/twirp/example.SearchService/';

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = fetch
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  
  public search(params: SearchRequest, headers: object = {}): Promise<SearchResponse> {
    return this.fetch(
      this.url('Search'),
      createTwirpRequest(params, headers)
    ).then((res) => {
      if (!res.ok) {
        return throwTwirpError(res)
      }
      return res.json().then((m) => { return SearchResponse.fromJSON(m)})
    })
  }
  
  public debug(params: google_protobuf.Empty, headers: object = {}): Promise<DebugResponse> {
    return this.fetch(
      this.url('Debug'),
      createTwirpRequest(params, headers)
    ).then((res) => {
      if (!res.ok) {
        return throwTwirpError(res)
      }
      return res.json().then((m) => { return DebugResponse.fromJSON(m)})
    })
  }
  
}